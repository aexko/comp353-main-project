import uuid

from django.db import models
from django.core.exceptions import ValidationError
from datetime import date, timedelta

class Person(models.Model):
    """
    Person model that serves as a base for all people-related models
    """
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    date_of_birth = models.DateField()
    social_security_number = models.CharField(max_length=20, unique=True, null=False, blank=False)
    medicare_card_number = models.CharField(max_length=20, unique=True)
    telephone_number = models.CharField(max_length=20)
    address = models.CharField(max_length=255)
    city = models.CharField(max_length=100)
    province = models.CharField(max_length=100)
    postal_code = models.CharField(max_length=10)
    email_address = models.EmailField(unique=True)

    class Meta:
        abstract = True


class Location(models.Model):
    """
    Represents a club location which can be the head location or a branch
    """
    TYPE_CHOICES = [
        ('Head', 'Head'),
        ('Branch', 'Branch'),
    ]
    type = models.CharField(max_length=10, choices=TYPE_CHOICES)
    name = models.CharField(max_length=255, unique=True)
    address = models.CharField(max_length=255)
    city = models.CharField(max_length=100)
    province = models.CharField(max_length=100)
    postal_code = models.CharField(max_length=10)
    phone_number = models.CharField(max_length=20)
    web_address = models.URLField(blank=True, null=True)
    max_capacity = models.PositiveIntegerField()

    def __str__(self):
        return f"{self.name} ({self.type})"


class Hobby(models.Model):
    """
    A list of hobbies that can be associated with club members
    """
    name = models.CharField(max_length=50, unique=True)

    def __str__(self):
        return self.name


class Log(models.Model):
    """
    Logs every email generated by the system
    """
    date = models.DateTimeField(auto_now_add=True)
    sender = models.CharField(max_length=255)
    receiver = models.EmailField()
    subject = models.CharField(max_length=255)
    body_snippet = models.TextField(max_length=100)

    def __str__(self):
        return f"Email to {self.receiver} on {self.date}"


class Personnel(Person):
    """
    Represents a person working at a club location
    """

    def __str__(self):
        return f"Personnel: {self.first_name} {self.last_name}"

    def current_role(self):
        """Get current active role"""
        current_assignment = self.personnelassignment_set.filter(end_date__isnull=True).first()
        return current_assignment.role if current_assignment else None

    def current_location(self):
        """Get current active location"""
        current_assignment = self.personnelassignment_set.filter(end_date__isnull=True).first()
        return current_assignment.location if current_assignment else None


class PersonnelAssignment(models.Model):
    """
    Links a personnel member to a location with specific dates, role, and mandate
    """
    ROLE_CHOICES = [
        ('Administrator', 'Administrator'),
        ('General Manager', 'General Manager'),
        ('Deputy Manager', 'Deputy Manager'),
        ('Treasurer', 'Treasurer'),
        ('Secretary', 'Secretary'),
        ('Captain', 'Captain'),
        ('Coach', 'Coach'),
        ('Assistant Coach', 'Assistant Coach'),
        ('Other', 'Other'),
    ]
    MANDATE_CHOICES = [
        ('Volunteer', 'Volunteer'),
        ('Salaried', 'Salaried'),
    ]

    personnel = models.ForeignKey(Personnel, on_delete=models.CASCADE)
    location = models.ForeignKey(Location, on_delete=models.CASCADE)
    role = models.CharField(max_length=50, choices=ROLE_CHOICES, default='Other')
    mandate = models.CharField(max_length=10, choices=MANDATE_CHOICES, default='Volunteer')
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)

    class Meta:
        db_table = 'club_personnelassignment'
        constraints = [
            models.CheckConstraint(
                check=models.Q(end_date__isnull=True) | models.Q(end_date__gte=models.F('start_date')),
                name='valid_date_range'
            ),
            models.UniqueConstraint(
                fields=['personnel', 'start_date'],
                name='unique_personnel_start_date'
            )
        ]

    def __str__(self):
        return f"{self.personnel} as {self.role} at {self.location} from {self.start_date}"


class FamilyMember(Person):
    """
    Represents a primary family member who can register minor club members
    """
    location = models.ForeignKey(Location, on_delete=models.SET_NULL, null=True, blank=True)

    def __str__(self):
        return f"Family Member {self.first_name} {self.last_name}"


class SecondaryFamilyMember(models.Model):
    """
    Represents a secondary contact for a family member
    """
    primary_family_member = models.ForeignKey(FamilyMember, on_delete=models.CASCADE, related_name='secondary_contacts')
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    telephone_number = models.CharField(max_length=20)
    relationship = models.CharField(max_length=50)

    def __str__(self):
        return f"Secondary Contact {self.first_name} {self.last_name}"

class ClubMember(Person):
    """
    Represents a club member who can be a minor or an adult
    """
    membership_number = models.CharField(max_length=36, unique=True, editable=False)
    height = models.DecimalField(max_digits=5, decimal_places=2)
    weight = models.DecimalField(max_digits=5, decimal_places=2)
    hobbies = models.ManyToManyField(Hobby, blank=True, through='ClubMemberHobby')
    location = models.ForeignKey(Location, on_delete=models.SET_NULL, null=True)
    date_joined = models.DateField(auto_now_add=True)
    gender = models.CharField(max_length=1, choices=[('M', 'Male'), ('F', 'Female')], default='M')

    class Meta:
        db_table = 'club_clubmember'

    def save(self, *args, **kwargs):
        if not self.membership_number:
            self.membership_number = str(uuid.uuid4())
        super().save(*args, **kwargs)

    def __str__(self):
        return f"Member: {self.first_name} {self.last_name}"

    def clean(self):
        # Constraint: Member must be at least 11 years old at registration
        if self.age < 11:
            raise ValidationError("Club member must be at least 11 years old to register.")

    @property
    def age(self):
        today = date.today()
        return today.year - self.date_of_birth.year - ((today.month, today.day) < (self.date_of_birth.month, self.date_of_birth.day))

    @property
    def is_minor(self):
        return self.age < 18

    @property
    def is_major(self):
        return self.age >= 18

    @property
    def annual_fee(self):
        """Constraint: $100 for minors, $200 for majors"""
        return 100.00 if self.is_minor else 200.00

    def total_payments_for_year(self, year):
        """Calculate total payments for a specific year"""
        return self.payment_set.filter(for_year=year).aggregate(
            total=models.Sum('amount')
        )['total'] or 0

    def is_fees_paid_for_year(self, year):
        """Check if annual fees are fully paid for a year"""
        return self.total_payments_for_year(year) >= self.annual_fee


class ClubMemberHobby(models.Model):
    """
    Through model for ClubMember and Hobby many-to-many relationship
    """
    clubmember = models.ForeignKey(ClubMember, on_delete=models.CASCADE)
    hobby = models.ForeignKey(Hobby, on_delete=models.CASCADE)

    class Meta:
        db_table = 'club_clubmember_hobbies'
        unique_together = ('clubmember', 'hobby')


class MinorMemberAssociation(models.Model):
    """
    Links a minor club member to a family member and defines their relationship
    """
    RELATIONSHIP_CHOICES = [
        ('Father', 'Father'), ('Mother', 'Mother'), ('Grand-father', 'Grand-father'),
        ('Grand-mother', 'Grand-mother'), ('Tutor', 'Tutor'), ('Partner', 'Partner'),
        ('Friend', 'Friend'), ('Other', 'Other'),
    ]
    minor_member = models.ForeignKey(ClubMember, on_delete=models.CASCADE)
    family_member = models.ForeignKey(FamilyMember, on_delete=models.CASCADE)
    relationship = models.CharField(max_length=20, choices=RELATIONSHIP_CHOICES)
    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)

    class Meta:
        db_table = 'club_minormemberassociation'
        constraints = [
            models.CheckConstraint(
                check=models.Q(end_date__isnull=True) | models.Q(end_date__gte=models.F('start_date')),
                name='valid_date_range_minor'
            ),
            models.UniqueConstraint(
                fields=['minor_member', 'start_date'],
                name='unique_minor_start_date'
            )
        ]

    def __str__(self):
        return f"{self.minor_member.first_name} ({self.relationship}) with {self.family_member.first_name}"


class Payment(models.Model):
    """
    Records a payment made by a club member
    """
    METHOD_CHOICES = [
        ('Cash', 'Cash'),
        ('Debit', 'Debit Card'),
        ('Credit', 'Credit Card'),
    ]
    club_member = models.ForeignKey(ClubMember, on_delete=models.CASCADE)
    payment_date = models.DateField()
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    method_of_payment = models.CharField(max_length=10, choices=METHOD_CHOICES)
    for_year = models.PositiveIntegerField()

    def __str__(self):
        return f"Payment by {self.club_member} for year {self.for_year}"


class TeamFormation(models.Model):
    """
    Represents a single team formation for a game or training session
    """
    location = models.ForeignKey(Location, on_delete=models.CASCADE)
    team_name = models.CharField(max_length=100)
    head_coach = models.ForeignKey(Personnel, on_delete=models.CASCADE, related_name='coached_teams')
    session_date = models.DateField()
    start_time = models.TimeField()
    session_address = models.CharField(max_length=255)
    is_game = models.BooleanField(default=False)
    score_team1 = models.PositiveIntegerField(null=True, blank=True)
    score_team2 = models.PositiveIntegerField(null=True, blank=True)

    def __str__(self):
        session_type = "Game" if self.is_game else "Training"
        return f"{self.team_name} {session_type} on {self.session_date} at {self.start_time}"


class PlayerAssignment(models.Model):
    """
    Links a club member to a team formation and assigns their role
    """
    PLAYER_ROLES = [
        ('Setter', 'Setter'),
        ('Outside hitter', 'Outside hitter'),
        ('Opposite hitter', 'Opposite hitter'),
        ('Middle blocker', 'Middle blocker'),
        ('Defensive specialist', 'Defensive specialist'),
        ('Libero', 'Libero'),
    ]
    club_member = models.ForeignKey(ClubMember, on_delete=models.CASCADE)
    team_formation = models.ForeignKey(TeamFormation, on_delete=models.CASCADE, related_name='players')
    role = models.CharField(max_length=50, choices=PLAYER_ROLES)

    class Meta:
        db_table = 'club_playerassignment'
        constraints = [
            models.UniqueConstraint(
                fields=['club_member', 'team_formation'],
                name='unique_member_formation'
            )
        ]

    def clean(self):
        # Validate minimum age (11 years old)
        if self.club_member.age < 11:
            raise ValidationError("Club member must be at least 11 years old.")

        # Validate same gender in team formation
        team_members = PlayerAssignment.objects.filter(team_formation=self.team_formation).exclude(pk=self.pk)
        if team_members.exists():
            existing_gender = team_members.first().club_member.gender
            if self.club_member.gender != existing_gender:
                raise ValidationError("All players in the same team must be of the same gender.")

        # Validate same location for all team members
        if self.club_member.location != self.team_formation.location:
            raise ValidationError("All players must be from the same location as the team formation.")

        # Validate 3-hour gap between team formations on same day
        same_day_assignments = PlayerAssignment.objects.filter(
            club_member=self.club_member,
            team_formation__session_date=self.team_formation.session_date
        ).exclude(pk=self.pk)

        for assignment in same_day_assignments:
            time_diff = abs((self.team_formation.start_time.hour * 60 + self.team_formation.start_time.minute) -
                          (assignment.team_formation.start_time.hour * 60 + assignment.team_formation.start_time.minute))
            if time_diff < 180:
                raise ValidationError("At least 3 hours gap required between team formations on the same day.")

    def save(self, *args, **kwargs):
        self.clean()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.club_member.first_name} as {self.role} in {self.team_formation.team_name}"
